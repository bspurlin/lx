var fs = require("fs"); 
var lxu = require("lxutils"); 
var os = require("os"); 
var settings = require("../../settings");
var pa = require("path"); 
var scanner = require(settings.scannerpath); 



var node_package_scan = function(message, headers, callback) { 
	var path = message["path"]; 
	var diff = message["diff"];
	fs.stat(path, function (err,stats) { 
		if(err) { 
			callback(err); 
		} 
		if(!stats.isDirectory()) { 
			callback(new Error("Indicated file at " + path + " is not a folder.")); 
			return; 
		} else { 
			// Scan the file programmatically and place the resulting output JSON
			// file in licenses folder; add JSON file's path name to hash table, 
			// then redirect the user to the proper route; 
			var dir = "";
			if(pa.basename(path) !== "node_modules") { 
				dir = pa.join(path,"node_modules"); 
			} else { 
				dir = path; 
				path = pa.dirname(path);
			}


			if(!fs.existsSync(dir)) { 
				callback(new Error("Indicated path at " + path + " does not have a node_modules folder.")); 
				return; 
			}
			scanner("node",dir,{prefix:path,diff_objects:diff}, function (error,licobjs) { 
			    if(error) { 
					return callback(error); 
				}						
				var newfilename = lxu.make_random_filename(settings.tmpdir,path,"json"); 
				lxu.writeJSON(newfilename,{"headers":headers,"data":licobjs},function() { 
					var jfile = lxu.hash(newfilename); 
					callback(null,jfile,newfilename); 
				}); 
			});
		}
	});
}; 

var python_package_scan = function(message, headers, callback) { 
	var path = message["path"]||"python"; 
	var package_name = message["name"]||null; 
	var diff = message["diff"]; 
	
	headers["package_name"] = package_name; 
	
	fs.stat(path, function (err,stats) { 
		if(err) { 
			return callback(err); 
		}
		if(!stats.isFile()) { 
			var py_name = lxu.format_binary_string("python"); 
			if(fs.existsSync(pa.join(path,py_name))) 
				path = pa.join(path,py_name); 
			else 
				path = "python"; 
		} 

		scanner("python",path,{package_name:package_name,diff_objects:diff},function (error, licobjs) { 
			if(error) 
				return callback(error);
			var newfilename = lxu.make_random_filename(settings.tmpdir,path,"json"); 
			lxu.writeJSON(newfilename,{"headers":headers,"data":licobjs},function() { 
				var jfile = lxu.hash(newfilename); 
				callback(null,jfile,newfilename); 
			});
		});
	}); 
};



var scanner_map = { 
	package_scan_handlers: { 
		"python": python_package_scan, 
		"": node_package_scan
	}
}



// Callback is called as callback(error,jfile,new_file_name)
module.exports.io = function(message_from_browser,callback) { 
	var jfiles = message_from_browser.jfiles;
	var diff; 
	var part_two = function () { 
		// Use path information to scan and redirect
		fs.exists(message_from_browser["path"],function (exists) { 
			if(exists) { 
				var headers = {
					"user": process.env.USER?process.env.USER:process.env.USERNAME,
			    	"date": Date(),
			        "path":  message_from_browser["path"],
			        "hostname": process.env.HOSTNAME?process.env.HOSTNAME:process.env.COMPUTERNAME,
			        "modified":[
			        	{
			        		"USER": process.env.USER?process.env.USER:process.env.USERNAME,
			        		"date": Date()
			        	}
			        ]
				}; 
				if(diff) { 
					headers.diff = diff.headers.path; 
					message_from_browser["diff"] = diff.data; 
				}
				scanner_map.package_scan_handlers[message_from_browser["scantype"]||""](message_from_browser,headers,callback);
			} else { 
				callback(new Error("Indicated file at " +message_from_browser["path"]+ " does not exist.")); 
			} 
		}); 
	};

	// Prepare the diff information to pass to the scanner
	if(message_from_browser["diff"] || message_from_browser["diff"]==="") { 
		diff = message_from_browser["diff"]; 
		if(diff!=="") { 
			try { 
				diff = JSON.parse(diff); 
				part_two(); 
			} catch (e) { 
				return callback(e,null); 
			}
		} else { 
			var jfile; 
			if(!(jfile = message_from_browser["jfile"]))
				return callback(new Error("No previous scan results available to diff against.")); 
			lxu.parseJSON(jfiles[jfile], function (error,json_data) { 
				diff = json_data; 
				part_two(); 
			}); 
		}
	}
	else 
		part_two(); 


};


module.exports.get = function(req,res) { 
	// This should only be reached when a different route (primarily the browser route curently)
	// redirects the user to this route
	var scantype = req.query.scantype||""; 
	res.redirect("/browse?scantype="+scantype+"&jfile="+req.query.jfile+"&caller=/scan?scan=true"+"&path="+pa.dirname(req.query.path)); 
};