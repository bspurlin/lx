var fs = require("fs"); 
var pa = require("path");
var _ = require("underscore"); 



// path 	a string giving the path to the JSON file to be parsed
// callback 	called with argument data, which is a JavaScript object representing
//		the JSON file 
// this function reads the indicated JSON file into an object which it passes to 
// the callback
var parseJSON = module.exports.parseJSON = function (path, callback) {

	if(typeof callback === "undefined") { 
		callback = function(){}; 
	}
	// Node maintains a cache matching file names to
	// file data for files that have been 
	// require()'d during the current session;
	// This deletes the cache entry so that the JSON
	// file is actually updated past the first time it's loaded


	delete require.cache[require.resolve(pa.resolve(path))]; 
	var data = require(pa.resolve(path));
	// Replaces encoded < and > symbols 
	data = JSON.parse(JSON.stringify(data).replace(/&lt;|&gt;/g,function(s){return s==="&lt;"?"<":">"})); 
	
	data.data = addLicensefiles(data.data); 
	callback(null,data); 

}


// path 	a string indicating the path to the file to be written
// data	an object to be written as its JSON representation to file
module.exports.writeJSON = function(path,data,callback) { 
	var newFile = JSON.stringify(data); 
	path = pa.resolve(path); 
	if(typeof callback === "undefined") 
		callback = function(){}; 
	// Create the file if it doesn't exist
	fs.open(path,"w",function (err,fd) {
		if(err) {
			callback(err); 
			return; 
		}
		fs.writeFile(path,newFile,function(err) { 
			if(err) { 
				callback(err); 
				return; 
			}
			callback(null); 
		}); 
	});

};

// Finds the index of the package with the given label
var findIndexByLabel = function(jfile,packlabel) {
	// This implementation relies on underscore's "pluck" function 
	// returning the label attributes of the passed in object 
	// in the same order that the objects themselves were in. 
	// Ex: _.pluck([{label: foo},{label:bar}],"label") = [foo,bar]. 
	// If this function seems broken that assumption could be incorrect
	return _.indexOf(_.pluck(jfile,"label"),packlabel);  
};

// This function adds missing licensefile objects to the given j(SON)file
var addLicensefiles = function(jfile) { 
	return _.map(jfile,function(item) { 
		if(typeof item.licensefile === "undefined" || typeof item.licensefile[0] === "undefined" || item.licensefile[0] === null) 
			item.licensefile = [ {} ]; 
		return item; 
	}); 
};

// data		an object to be updated 
// prop 	a string with the key name of the property to be created 
// begvalue	an object to which to initialize the created property value
// path...	an indefinite number of string arguments representing the series of \
//	 		subobjects to navigate
// createprop adds a (key,value) pair to a javascript object by navigating the object \
// tree as indicated by the path arguments; \
// Ex: createprop(data,"key","value","first","second","third","fourth") returns a copy of data \
// modified by adding data["first"]["second"]["third"]["fourth"]["key"] = "value"
var createprop = function(data,prop,begvalue,path) { 
	begvalue = begvalue || ""; 
	path = path || ""; 
	var rval = data; 
	if(path === "" || typeof path === "undefined") { 
		// Assigns property value in the default case
		rval[prop] = begvalue; 
	} else {
		// Create object in path if it doesn't exist
		if(typeof rval[path] === "undefined") {  
			rval[path] = {}; 
		}
		// Check for typing problems 
		if(typeof rval[path] === "string") { 
			throw new Error("Intermediary path members must be objects when calling createprop. Path was: " + arguments.split(3,arguments.length-1).toString()); 
		}
		// There is only one path member; assign value
		if(arguments.length<5) { 
			rval[path][prop] = begvalue; 
		} else { 
			// There is more than one path member; recursive call 
			var args = [rval[path],prop,begvalue]; 
			for(var i = 4;i<arguments.length;i++) { 
				args[i-1] = arguments[i]; 
			}
			rval[path] = createprop.apply(this, args); 
		} 
	}
	return rval; 
		 	
}; 

// data 	an object to be modified
// prop 	a string, the property in jfile to be modified
// newvalue	a string, the replacement value
// create	a boolean value, if true indicates that the property should be created and then assigned
// This function does a depth-first recursive search of an object, finds
// the indicated (string-valued) property within the object, and replaces
// that property's value with newvalue.
// Note: Assumes there's only one property which matches prop anywhere in jfile's tree
var updateByProperty = function(data,prop,newvalue,create,path) { 
    path = path || ""; 
	create = typeof create !== "undefined" ? true : false;
	var rval = data; 

	
	if(prop instanceof Array) { 
	// In this case we make a recursive check; for now better not put in a bad path for the property
		if(prop.length===1) {
			// Base case 
			prop = prop[0]; 
		} else { 
			// Recursive case
			var newprop = prop.slice(1,prop.length); 
			rval[prop[0]] = updateByProperty(rval[prop[0]],newprop,newvalue,create,path); 
			return rval; 
		}
	}


	for (var property in rval) {
		if(rval.hasOwnProperty(property)) {  
			var val = rval[property]; 
			if(typeof val === "string" && property === prop) { 
				rval[property] = newvalue; 
				return rval;
			} else if (val instanceof Array) {
				(rval[property]) = _.map(rval[property], function (item) { 
					return updateByProperty(item,prop,newvalue); 
				}); 
			} else if(typeof val === "object") { 
				rval[property] = updateByProperty(rval[property],prop,newvalue); 
			}
		}
	}
	
	// Checks if value needs to be created	
	if(typeof rval[prop] === "undefined" && create) { 
		var args = [rval,prop,newvalue];
		for(var i = 4;i<arguments.length;i++) { 
			args[i-1] = arguments[i]; 
		} 
		rval = createprop.apply(this,args); 
	}

	return rval; 
}; 


var updateInPackage = function(jfile,packlabel,prop,newvalue,create,path) { 
	create = typeof create!== "undefined" ? create : false; 
	path = path || ""; 
	var index = findIndexByLabel(jfile,packlabel);
	if(index===-1) { 
		throw new Error("No package with given label " + packlabel + " found."); 
		return; 
	} 
	jfile[index] = updateByProperty(jfile[index],prop,newvalue,create,path); 
	return jfile; 
};

// Generates a file name of the form <file_name><random number between 0 and 1000>.<extension>
module.exports.make_random_filename = function (new_file_path,old_file_path,extension) { 
	var base_name_and_numbers = pa.basename(old_file_path).split(".")[0]; 
	base_name_and_numbers += Math.floor(Math.random() * (1000)).toString() + "."+extension;
	return pa.join(new_file_path,pa.sep+base_name_and_numbers);
}; 

// Formats a binary name into a name that's appropriate for the current operating system 
module.exports.format_binary_string = function (string) { 
	var os = require("os"); 

	var ext = ""; 
	switch(os.platform()) { 
		case "win32": 
			ext = ".exe"; 
			break; 
	}

	return string + ext; 
}; 

// jfile 	an object which contains licensing information 
// packlabel	the label of the package within the licensing information whose license text should be returned
// index 	a non-negative number indicating which of the licenses associated with the given package should be accessed
var getPackText = module.exports.getPackText = function(jfile,packlabel,index) { 
	var packindex = findIndexByLabel(jfile.data,packlabel); 
	return jfile.data[packindex].licensefile[index].text; 
}

// path 	a string, path to JSON file to be modified
// packlabel 	a string, package label of package entry to be modified
// newurl	a string, self-explanatory
module.exports.updateJPath = function(jfile,packlabel,newurl,index) { 
	jfile.data = updateInPackage(jfile.data,packlabel,["licensefile",index,"licensepath"],newurl)
	return jfile; 
};

module.exports.updateJNote = function(jfile,packlabel,newnotice,index) {  
	jfile.data = updateInPackage(jfile.data,packlabel,["licensefile",index,"notice"],newnotice);
	return jfile; 
};

module.exports.updateJHome = function(jfile,packlabel,newhome) { 
	jfile.data = updateInPackage(jfile.data,packlabel,"homepage",newhome); 
	return jfile;
}

module.exports.updateJType = function(jfile,packlabel,newtype) {  
	var newfile = jfile.data; 
	newfile = updateInPackage(newfile,packlabel,"type",newtype);
	if(jfile.data!==newfile) { 
		jfile.data = newfile;
		return jfile; 
	}
	newfile = updateInPackage(newfile,packlabel,"license",newtype,true); 
	jfile.data = newfile;
	return jfile;
}; 

module.exports.updateJMods = function(jfile) { 
	jfile.headers.modified.push({USER: process.env.USER?process.env.USER:process.env.USERNAME,
		   "date": Date()});
	return jfile; 	
}


// path 	a string pointing to the JSON file to be rendered
// view		a string which is the name of the view to use when rendering
// params	an object which is passed to the rendering engine
// response	a response object from express 
module.exports.jRender = function(path, view, params,response) { 
	parseJSON(path, function(err,json) {
		params.packages = json.data; 
		params.headers = json.headers;
		response.render(view, params);
	});
}




module.exports.hash = function(s) {
	var hash = 0,
		i, char;
	if (s.length == 0) return hash;
	for (i = 0;i < s.length; i++) {
		char = s.charCodeAt(i);
		hash = ((hash << 5) - hash) + char;
		hash |= 0; // Convert to 32bit integer
	}
	return hash;
};	
